import random

items_effective_cpp = [
    "Effective C++",
    "Item 1: View C++ as a federation of languages. 11A",
    "Item 2: Prefer consts, enums, and inlines to #defines. 13A",
    "Item 3: Use const whenever possible. 17A",
    "Item 4: Make sure that objects are initialized before they’re used. 26A",
    "Item 5: Know what functions C++ silently writes and calls. 34A",
    "Item 6: Explicitly disallow the use of compiler-generated functions you do not want. 37A",
    "Item 7: Declare destructors virtual in polymorphic base classes. 40A",
    "Item 8: Prevent exceptions from leaving destructors. 44A",
    "Item 9: Never call virtual functions during construction or destruction. 48A",
    "Item 10: Have assignment operators return a reference to *this. 52A",
    "Item 11: Handle assignment to self in operator=. 53A",
    "Item 12: Copy all parts of an object. 57A",
    "Item 13: Use objects to manage resources. 61A",
    "Item 14: Think carefully about copying behavior in resourcemanaging classes. 66A",
    "Item 15: Provide access to raw resources in resourcemanaging classes. 69A",
    "Item 16: Use the same form in corresponding uses of new and delete. 73A",
    "Item 17: Store newed objects in smart pointers in standalone statements. 75A",
    "Item 18: Make interfaces easy to use correctly and hard to use incorrectly. 78A",
    "Item 19: Treat class design as type design. 84A",
    "Item 20: Prefer pass-by-reference-to-const to pass-by-value. 86A",
    "Item 21: Don’t try to return a reference when you must return an object. 90A",
    "Item 22: Declare data members private. 94A",
    "Item 23: Prefer non-member non-friend functions to member functions. 98A",
    "Item 24: Declare non-member functions when type conversions should apply to all parameters. 102A",
    "Item 25: Consider support for a non-throwing swap. 106A",
    "Item 26: Postpone variable definitions as long as possible. 113A",
    "Item 27: Minimize casting. 116A",
    "Item 28: Avoid returning “handles” to object internals. 123A",
    "Item 29: Strive for exception-safe code. 127A",
    "Item 30: Understand the ins and outs of inlining. 134A",
    "Item 31: Minimize compilation dependencies between files. 140A",
    "Item 32: Make sure public inheritance models “is-a.” 150A",
    "Item 33: Avoid hiding inherited names. 156A",
    "Item 34: Differentiate between inheritance of interface and inheritance of implementation. 161A",
    "Item 35: Consider alternatives to virtual functions. 169A",
    "Item 36: Never redefine an inherited non-virtual function. 178A",
    "Item 37: Never redefine a function’s inherited default parameter value. 180A",
    "Item 38: Model “has-a” or “is-implemented-in-terms-of” through composition. 184A",
    "Item 39: Use private inheritance judiciously. 187A",
    "Item 40: Use multiple inheritance judiciously. 192A",
    "Item 41: Understand implicit interfaces and compile-time polymorphism. 199A",
    "Item 42: Understand the two meanings of typename. 203A",
    "Item 43: Know how to access names in templatized base classes. 207A",
    "Item 44: Factor parameter-independent code out of templates. 212A",
    "Item 45: Use member function templates to accept “all compatible types.” 218A",
    "Item 46: Define non-member functions inside templates when type conversions are desired. 222A",
    "Item 47: Use traits classes for information about types. 226A",
    "Item 48: Be aware of template metaprogramming. 233A",
    "Item 49: Understand the behavior of the new-handler. 240A",
    "Item 50: Understand when it makes sense to replace new and delete. 247A",
    "Item 51: Adhere to convention when writing new and delete. 252A",
    "Item 52: Write placement delete if you write placement new. 256A",
    "Item 53: Pay attention to compiler warnings. 262A",
    "Item 54: Familiarize yourself with the standard library, including TR1. 263A",
    "Item 55: Familiarize yourself with Boost. 269A"
]

items_more_effective_cpp = [
    "More Effective C++",
    "Item 1: Distinguish between pointers and references. 9B",
    "Item 2: Prefer C++-style casts. 12B",
    "Item 3: Never treat arrays polymorphically. 16B",
    "Item 4: Avoid gratuitous default constructors. 19B",
    "Item 5: Be wary of user-defined conversion functions. 24B",
    "Item 6: Distinguish between prefix and postfix forms of increment and decrement operators. 31B",
    "Item 7: Never overload &&, ||, or ,. 35B",
    "Item 8: Understand the different meanings of new and delete. 38B",
    "Item 9: Use destructors to prevent resource leaks. 45B",
    "Item 10: Prevent resource leaks in constructors. 50B",
    "Item 11: Prevent exceptions from leaving destructors. 58B",
    "Item 12: Understand how throwing an exception differs from passing a parameter or calling a virtual function. 61B",
    "Item 13: Catch exceptions by reference. 68B",
    "Item 14: Use exception specifications judiciously. 72B",
    "Item 15: Understand the costs of exception handling. 78B",
    "Item 16: Remember the 80-20 rule. 82B",
    "Item 17: Consider using lazy evaluation. 85B",
    "Item 18: Amortize the cost of expected computations. 93B",
    "Item 19: Understand the origin of temporary objects. 98B",
    "Item 20: Facilitate the return value optimization. 101B",
    "Item 21: Overload to avoid implicit type conversions. 105B",
    "Item 22: Consider using op= instead of stand-alone op. 107B",
    "Item 23: Consider alternative libraries. 110B",
    "Item 24: Understand the costs of virtual functions, multiple inheritance, virtual base classes, and RTTI. 113B",
    "Item 25: Virtualizing constructors and non-member functions. 123B",
    "Item 26: Limiting the number of objects of a class. 130B",
    "Item 27: Requiring or prohibiting heap-based objects. 145B",
    "Item 28: Smart pointers. 159B",
    "Item 29: Reference counting. 183B",
    "Item 30: Proxy classes. 213B",
    "Item 31: Making functions virtual with respect to more than one object. 228B",
    "Item 32: Program in the future tense. 252B",
    "Item 33: Make non-leaf classes abstract. 258B",
    "Item 34: Understand how to combine C++ and C in the same program. 270B",
    "Item 35: Familiarize yourself with the language standard. 277B"
]

items_effective_stl = [
    "Effective STL",
    "Item 1: Choose your containers with care. 11C",
    "Item 2: Beware the illusion of container-independent code. 15C",
    "Item 3: Make copying cheap and correct for objects in containers. 20C",
    "Item 4: Call empty instead of checking size() against zero. 23C",
    "Item 5: Prefer range member functions to their single-element counterparts. 24C",
    "Item 6: Be alert for C++’s most vexing parse. 33C",
    "Item 7: When using containers of newed pointers, remember to delete the pointers before the container is destroyed. 36C",
    "Item 8: Never create containers of auto_ptrs. 40C",
    "Item 9: Choose carefully among erasing options. 43C",
    "Item 10: Be aware of allocator conventions and restrictions. 48C",
    "Item 11: Understand the legitimate uses of custom allocators. 54C",
    "Item 12: Have realistic expectations about the thread safety of STL containers. 58C",
    "Item 13: Prefer vector and string to dynamically allocated arrays. 63C",
    "Item 14: Use reserve to avoid unnecessary reallocations. 66C",
    "Item 15: Be aware of variations in string implementations. 68C",
    "Item 16: Know how to pass vector and string data to legacy APIs. 74C",
    "Item 17: Use “the swap trick” to trim excess capacity. 77C",
    "Item 18: Avoid using vector<bool>. 79C",
    "Item 19: Understand the difference between equality and equivalence. 83C",
    "Item 20: Specify comparison types for associative containers of pointers. 88C",
    "Item 21: Always have comparison functions return false for equal values. 92C",
    "Item 22: Avoid in-place key modification in set and multiset. 95C",
    "Item 23: Consider replacing associative containers with sorted vectors. 100C",
    "Item 24: Choose carefully between map::operator[] and map::insert when efficiency is important. 106C",
    "Item 25: Familiarize yourself with the nonstandard hashed containers. 111C",
    "Item 26: Prefer iterator to const_iterator, reverse_iterator, and const_reverse_iterator. 116C",
    "Item 27: Use distance and advance to convert a container’s const_iterators to iterators. 120C",
    "Item 28: Understand how to use a reverse_iterator’s base iterator. 123C",
    "Item 29: Consider istreambuf_iterators for character-bycharacter input. 126C",
    "Item 30: Make sure destination ranges are big enough. 129C",
    "Item 31: Know your sorting options. 133C",
    "Item 32: Follow remove-like algorithms by erase if you really want to remove something. 139C",
    "Item 33: Be wary of remove-like algorithms on containers of pointers. 143C",
    "Item 34: Note which algorithms expect sorted ranges. 146C",
    "Item 35: Implement simple case-insensitive string comparisons via mismatch or lexicographical_compare. 150C",
    "Item 36: Understand the proper implementation of copy_if. 154C",
    "Item 37: Use accumulate or for_each to summarize ranges. 156C",
    "Item 38: Design functor classes for pass-by-value. 162C",
    "Item 39: Make predicates pure functions. 166C",
    "Item 40: Make functor classes adaptable. 169C",
    "Item 41: Understand the reasons for ptr_fun, mem_fun, and mem_fun_ref. 173C",
    "Item 42: Make sure less<T> means operator<. 177C",
    "Item 43: Prefer algorithm calls to hand-written loops. 181C",
    "Item 44: Prefer member functions to algorithms with the same names. 190C",
    "Item 45: Distinguish among count, find, binary_search, lower_bound, upper_bound, and equal_range. 192C",
    "Item 46: Consider function objects instead of functions as algorithm parameters. 201C",
    "Item 47: Avoid producing write-only code. 206C",
    "Item 48: Always #include the proper headers. 209C",
    "Item 49: Learn to decipher STL-related compiler diagnostics. 210C",
    "Item 50: Familiarize yourself with STL-related web sites. 217C"
]

item_lists = [items_effective_cpp, items_more_effective_cpp, items_effective_stl]

def meyersItem():
    items = random.choice(item_lists)
    out = items[0] + " "
    out += random.choice(items[1:])
    return out




    
    
